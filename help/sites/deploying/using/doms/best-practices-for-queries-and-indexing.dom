<?xml version="1.1" encoding="UTF-8" standalone="yes"?> 
<html> 
 <head> 
  <meta content="https://helpx.adobe.com/experience-manager/6-4/sites/deploying/using/best-practices-for-queries-and-indexing.html" name="publishExternalURL" /> 
  <meta content="/content/help/en/experience-manager/6-4/sites/deploying/morehelp/best-practices;/content/help/en/experience-manager/6-4/sites/deploying/morehelp/best-practices" name="moreHelpPaths" /> 
  <meta content="admin" name="jcr:createdBy" /> 
  <meta content="Best Practices for Queries and Indexing" name="seoTitle" /> 
  <meta content="https://helpx-internal.corp.adobe.com/content/help/en/experience-manager/6-4/sites/deploying/using/best-practices-for-queries-and-indexing.html" name="publishInternalURL" /> 
  <meta content="2018-04-06T11:51:42.900-0400" name="topicBrowsingSortDate" /> 
  <meta content="dgonzale" name="cq:lastReplicatedBy" /> 
  <meta content="false" name="isReadyForLocalization" /> 
  <meta content="audience:deploying" name="primaryAudienceTag" /> 
  <meta content="2017-12-01T19:05:57.331-0500" name="jcr:created" /> 
  <meta content="2018-04-30T03:26:41.976-0400" name="locHandOffDate" /> 
  <meta content="help/components/pages/article-3" name="sling:resourceType" /> 
  <meta content="/etc/designs/help" name="cq:designPath" /> 
  <meta content="2017-10-31T16:18:14.399-0400" name="firstPublishExternalDate" /> 
  <meta content="2018-04-06T11:51:42.900-0400" name="lastPublishExternalDate" /> 
  <meta content="raiman" name="cq:lastModifiedBy" /> 
  <meta content="2018-04-06T11:51:42.900-0400" name="firstPublishInternalDate" /> 
  <meta content="" name="jcr:baseVersion" /> 
  <meta content="Best Practices for Queries and Indexing" name="jcr:title" /> 
  <meta content="2017-10-12T21:46:00.000-0400" name="qaDate" /> 
  <meta content="products:SG_EXPERIENCEMANAGER/6.4/SITES" name="primaryProductTag" /> 
  <meta content="2018-04-06T11:51:42.900-0400" name="publishInternalDate" /> 
  <meta content="" name="jcr:versionHistory" /> 
  <meta content="e10bb330-d87c-43c7-9b07-19e8d4364118" name="jcr:predecessors" /> 
  <meta content="en_us" name="jcr:language" /> 
  <meta content="User" name="contentOwner" /> 
  <meta content="2018-04-06T11:51:42.900-0400" name="publishExternalDate" /> 
  <meta content="2018-04-06T11:51:42.900-0400" name="lastPublishInternalDate" /> 
  <meta content="2018-04-06T11:51:43.104-0400" name="cq:lastReplicated" /> 
  <meta content="mix:versionable" name="jcr:mixinTypes" /> 
  <meta content="2018-10-17T09:47:00.712-0400" name="cq:lastModified" /> 
  <meta content="b7155718-090a-4a4f-8840-72757de394e2" name="jcr:uuid" /> 
  <meta content="true" name="jcr:isCheckedOut" /> 
  <meta content="/content/docs/en/aem/6-3/deploy/best-practices/best-practices-for-queries-and-indexing" name="qaNotes" /> 
  <meta content="dgonzale@adobe.com" name="lr_lastReplicatedBy" /> 
  <meta content="Best Practices for Queries and Indexing" name="navTitle" /> 
  <meta content="" name="jcr:primaryType" /> 
  <meta content="Activate" name="cq:lastReplicationAction" /> 
  <meta content="2017-10-12T21:46:58.665-0400" name="mwpw_migration_script_version" /> 
  <meta content="products:SG_EXPERIENCEMANAGER/6.4/SITES;content_type:reference;topic_tags:best-practices" name="cq:tags" /> 
  <meta content="This article provides guidelines on how to optimize your indexes and queries." name="seoDescription" /> 
  <meta content="/apps/help/templates/article-3" name="cq:template" /> 
 </head> 
 <body> 
  <p>Along with the transition to Oak in AEM 6, some major changes were made to the way that queries and indexes are managed. Under Jackrabbit 2, all content was indexed by default and could be queried freely. In Oak, indexes must be created manually under the <span class="code">oak:index</span> node. A query can be executed without an index, but for large datasets, it will execute very slowly, or even abort.</p> 
  <p>This article will outline when to create indexes as well as when they are not needed, tricks to avoid using queries when they are not necessary, and tips for optimizing your indexes and queries to perform as optimally as possible.</p> 
  <p>Additionally, make sure to read the <a href="../../../sites/deploying/using/queries-and-indexing.md">Oak documentation on writing queries and indexes</a>. In addition to indexes being a new concept in AEM 6, there are syntactical differences in Oak queries that need to be taken into account when migrating code from a previous AEM installation.</p> 
  <h2>When to Use Queries</h2> 
  <h3>Repository and Taxonomy Design</h3> 
  <p>When designing the taxonomy of a repository, several factors need to be taken into account. These include access controls, localization, component and page property inheritance among others.</p> 
  <p>While designing a taxonomy that addresses these concerns, it is also important to consider the "traversability" of the indexing design. In this context, the traversability is the ability of a taxonomy that allows content to be predictably accessed based on its path. This will make for a more performant system that is easier to maintain than one that will require a lot of queries to be executed.</p> 
  <p>Additionally, when designing a taxonomy, it is important to consider whether ordering is important. In cases where explicit ordering is not required and a large number of sibling nodes are expected, it is preferred to use an unordered node type such as <span class="code">sling:Folder</span> or <span class="code">oak:Unstructured</span>. In cases where ordering is required, <span class="code">nt:unstructured</span> and <span class="code">sling:OrderedFolder</span> would be more appropriate.</p> 
  <h3>Queries in Components</h3> 
  <p>Since queries can be one of the more taxing operations done on an AEM system, it is a good idea to avoid them in your components. Having several queries execute each time a page is rendered can often degrade the performance of the system. There are two strategies that can be used to avoid executing queries when rendering components: <strong>traversing nodes</strong> and <strong>prefetching results</strong>.</p> 
  <h4>Traversing Nodes</h4> 
  <p>If the repository is designed in such a way that allows prior knowledge of the location of the required data, code that retrieves this data from the necessary paths can be deployed without having to run queries in order to find it.</p> 
  <p>An example of this would be rendering content that fits within a certain category. One approach would be to organize the content with a category property that can be queried to populate a component that shows items in a category.</p> 
  <p>A better approach would be to structure this content in a taxonomy by category so that it can be manually retrieved.</p> 
  <p>For example, if the content is stored in a taxonomy similar to:</p> 
  <codeblock class="syntax xml">
    /content/myUnstructuredContent/parentCategory/childCategory/contentPiece 
  </codeblock> 
  <p>the <span class="code">/content/myUnstructuredContent/parentCategory/childCategory</span> node can simply be retrieved, its children can be parsed and used to render the component.</p> 
  <p>Additionally, when you are dealing with a small or homogenous result set, it can be faster to traverse the repository and gather the required nodes, rather than crafting a query to return the same result set. As a general consideration, queries should be avoided where it is possible to do so.</p> 
  <h4>Prefetching Results</h4> 
  <p>Sometimes the content or the requirements around the component will not allow the use of node traversal as a method of retrieving the required data. In these cases, the required queries need to be executed before the component is rendered so that optimal performance is ensured for the end user.</p> 
  <p>If the results that are required for the component can be calculated at the time that it is authored and there is no expectancy that the content will change, the query can be executed when the author applies settings in the dialog.</p> 
  <p>If the data or content will change regularly, the query can be executed on a schedule or via a listener for updates to the underlying data. Then, the results can be written to a shared location in the repository. Any components that need this data can then pull the values from this single node without needing to execute a query at runtime.<br /> </p> 
  <h2>Query Optimization</h2> 
  <p>When running a query that is not using an index, warnings will be logged regarding node traversal. If this is a query that is going to be run often, an index should be created. To determine which index a given query is using, the <a href="../../../sites/administering/using/operations-dashboard.md#main-pars-title-1097830066">Explain Query tool</a> is recommended. For additional information, DEBUG logging can be enabled for the relevant search APIs.</p> 
  <note> 
   <p>After modifying an index definition, the index needs to be rebuilt (reindexed). Depending on the size of the index, this may take some time to complete.</p> 
  </note> 
  <p>When running complex queries, there may be cases in which breaking down the query into multiple smaller queries and joining the data through code after the fact is more performant. The recommendation for these cases is to compare performance of the two approaches to determine which option would be better for the use case in question.</p> 
  <p>AEM allows writing queries in one of three ways:</p> 
  <ul> 
   <li>Via the <a href="../../../sites/developing/using/querybuilder-api.md">QueryBuilder APIs</a> (recommended)</li> 
   <li>Using XPath (recommended)</li> 
   <li>Using SQL2</li> 
  </ul> 
  <p>While all queries are converted to SQL2 before being run, the overhead of query conversion is minimal and thus, the greatest concern when choosing a query language will be readability and comfort level from the development team.</p> 
  <note> 
   <p>When using QueryBuilder, it will determine the result count by default, which is slower in Oak as compared to previous versions of Jackrabbit. To compensate for this, you can use the <a href="../../../sites/developing/using/querybuilder-api.md#main-pars-title-2032974994">guessTotal parameter</a>.</p> 
  </note> 
  <h3>The Explain Query Tool</h3> 
  <p>As with any query language, the first step to optimizing a query is to understand how it will be executed. To enable this activity, you can use the <a href="../../../sites/administering/using/operations-dashboard.md#main-pars-title-1097830066">Explain Query tool</a> that is part of the Operations Dashboard. With this tool, a query can be plugged in and explained. A warning will be shown if the query will cause issues with a large repository as well as execution time and the indexes that will be used. The tool can also load a list of slow and popular queries that can then be explained and optimized.</p> 
  <h3>DEBUG Logging for Queries</h3> 
  <p>To get some additional information about how Oak is choosing which index to use and how the query engine is actually executing a query, a <strong>DEBUG</strong> logging configuration can be added for the following packages: </p> 
  <ul> 
   <li>org.apache.jackrabbit.oak.plugins.index</li> 
   <li>org.apache.jackrabbit.oak.query</li> 
   <li>com.day.cq.search</li> 
  </ul> 
  <p>Make sure to remove this logger when you have finished debugging your query as it will output a lot of activity and can eventually fill up your disk with log files.</p> 
  <p>For more information on how to do this, see the <a href="../../../sites/deploying/using/configure-logging.md">Logging documentation</a>.</p> 
  <h3>Index Statistics</h3> 
  <p>Lucene registers a JMX bean that will provide details about indexed content including the size and number of documents present in each of the indexes.</p> 
  <p>You can reach it by accessing the JMX Console at <span class="code">http://server:port/system/console/jmx</span><br /> </p> 
  <p>Once you are logged in to the JMX console, perform a search for <strong>Lucene Index Statistics</strong> in order to find it. Other index statistics can be found in the <strong>IndexStats</strong> MBean.</p> 
  <p>For query statistics, take a look at the MBean named <strong>Oak Query Statistics</strong>.</p> 
  <p>If you would like to dig into your indexes using a tool like <a href="https://code.google.com/p/luke/">Luke</a>, you will need to use the Oak console to dump the index from the <span class="code">NodeStore</span> to a filesystem directory. For instructions on how to do this, please read the <a href="http://jackrabbit.apache.org/oak/docs/query/lucene.html">Lucene documentation</a>.</p> 
  <p>You can also extract the indexes in your system in JSON format. In order to do this, you need to access <span class="code">http://server:port/oak:index.tidy.-1.json</span></p> 
  <h3>Query Limits</h3> 
  <p><strong>During Development</strong></p> 
  <div class="text"> 
   <p>Set low threshholds for <span class="code">oak.queryLimitInMemory</span> (eg. 10000) and oak.<span class="code">queryLimitReads</span> (eg. 5000) and optimize the expensive query when hitting an UnsupportedOperationException saying â€œThe query read more than x nodes..."</p> 
   <p>This helps avoiding resource intensive queries (ie. not backed by any index or backed by less covering index). For example, a query that reads 1 million nodes would lead to increased I/O, and negatively impact the overall application performance. Any query that fails due to above limits should be analyzed and optimized.</p> 
  </div> 
  <h4><strong>Post-Deployment</strong></h4> 
  <div class="text"> 
   <ul> 
    <li>Monitor the logs for queries triggering large node traversal or large heap memory consumption :<span class="code"> </span> 
     <ul> 
      <li><span class="code">*WARN* ... java.lang.UnsupportedOperationException: The query read or traversed more than 100000 nodes. To avoid affecting other tasks, processing was stopped.</span></li> 
      <li>Optimize the query to reduce the number of traversed nodes</li> 
     </ul> </li> 
    <li>Monitor the logs for queries triggering large heap memory consumption : 
     <ul> 
      <li><span class="code">*WARN* ... java.lang.UnsupportedOperationException: The query read more than 500000 nodes in memory. To avoid running out of memory, processing was stopped</span></li> 
      <li>Optimize the query to reduce the heap memory consumption</li> 
     </ul> </li> 
   </ul> 
   <p>For AEM 6.0 - 6.2 versions, you can tune the threshold for node traversal via JVM parameters in the AEM start script to prevent large queries from overloading the environment.</p> 
   <p>The recommended values are :</p> 
   <ul> 
    <li><span class="code">-Doak.queryLimitInMemory=500000</span></li> 
    <li><span class="code">-Doak.queryLimitReads=100000</span></li> 
   </ul> 
   <p>In AEM 6.3, the above 2 parameters are preconfigured OOTB, and can be persisted via the OSGi QueryEngineSettings.</p> 
   <p>More information available under : <a class="external-link" data-ext-link-init="true" target="_blank">http://jackrabbit.apache.org/oak/docs/query/query-engine.html#Slow_Queries_and_Read_Limits</a></p> 
  </div> 
  <h2>Tips for Creating Efficient Indexes</h2> 
  <h3>Should I Create an Index?</h3> 
  <p>The first question to ask when creating or optimizing indexes is whether they are really required for a given situation. If you are only going to run the query in question once or only occasionally and at an off-peak time for the system through a batch process, it may be better to not create an index at all. </p> 
  <p>After creating an index, every time the indexed data is updated, the index must be updated as well. Since this carries performance implications for the system, indexes should only be created when they are actually required.</p> 
  <p>Additionally, indexes are only useful if the data contained within the index is unique enough to warrant it. Consider an index in a book and the topics that it covers. When indexing a set of topics in a text, usually there will be hundreds or thousands of entries, which allows you to quickly jump to a subset of pages to quickly find the information that you are looking for. If that index only had two or three entries, each pointing you to several hundred pages, the index would not be very useful. This same concept applies to database indexes. If there are only a couple unique values, the index will not be very useful. That being said, an index can also become too large to be useful as well. To look at index statistics, see <a href="../../../sites/deploying/using/best-practices-for-queries-and-indexing.md#main-pars-title-1472859131">Index Statistics</a> above.</p> 
  <h3>Lucene or Property Indexes?</h3> 
  <p>Lucene indexes were introduced in Oak 1.0.9 and offer some powerful optimizations over the property indexes that were introduced in the initial launch of AEM 6. When deciding whether to use Lucene indexes or property indexes, take the following into consideration:</p> 
  <ul> 
   <li>Lucene indexes offer many more features than property indexes. For example, a property index can only index a single property while a Lucene index can include many. For more information on all of the features available in Lucene indexes, consult the <a href="http://jackrabbit.apache.org/oak/docs/query/lucene.html">documentation</a>.</li> 
   <li>Lucene indexes are asynchronous. While this offers a considerable performance boost, it can also induce a delay between when data is written to the repository and when the index is updated. If it is vital to have queries return 100% accurate results, a property index would be required.</li> 
   <li>By virtue of being asynchronous, Lucene indexes cannot enforce uniqueness constraints. If this is required, then a property index will need to be put in place.</li> 
  </ul> 
  <p>In general, it is recommended you use Lucene indexes unless there is a compelling need to use property indexes so that you can gain the benefits of higher performance and flexibility.</p> 
  <h3>Solr Indexing</h3> 
  <p>AEM also provides support for Solr indexing by default. This is mainly leveraged to support full text search, but it can also be used to support any type of JCR query. Solr should be considered when the AEM instances do not have the CPU capacity to handle the number of queries required in search intensive deployments like search driven websites with a high number of concurrent users. Alternately, Solr can be implemented in a crawler based approach to leverage some of the more advanced features of the platform.</p> 
  <p>Solr indexes can be configured to run embedded on the AEM server for development environments or can be offloaded to a remote instance to improve search scalability on the production and staging environments. While offloading search will improve scalability, it will introduce latency and because of this, is not recommended unless required. For more info on how to configure Solr integration and how to create Solr indexes see the <a href="../../../sites/deploying/using/queries-and-indexing.md#main-pars-title-5">Oak Queries and Indexing documentation</a>.</p> 
  <note> 
   <p>While taking the integrated Solr search approach would allow for offloading of indexing to a Solr server. If the more advanced features of the Solr server are used through a crawler based approach, additional configuration work will be required. Headwire has created an <a href="http://www.aemsolrsearch.com/#/">open source connector</a> to accelerate these types of implementations.</p> 
  </note> 
  <p>The downside to taking this approach is that while by default, AEM queries will respect ACLs and thus hide results that a user does not have access to, externalizing search to a Solr server will not support this feature. If search is to be externalized in this way, extra care must be taken to ensure that users are not presented with results that they should not see.</p> 
  <p>Potential use cases where this approach may be appropriate are cases where search data from multiple sources may need to be aggregated. For instance, you may have a site being hosted on AEM as well as a second site being hosted on a third party platform. Solr could be configured to crawl the content of both sites and store them in an aggregated index. This would allow for cross-site searches.</p> 
  <h3>Design Considerations</h3> 
  <p>The Oak documentation for Lucene indexes lists several considerations to make when designing indexes:</p> 
  <ul> 
   <li>If the query uses different path restrictions, utilize <span class="code">evaluatePathRestrictions</span>. This will allow the query to return the subset of results under the path specified and then filter them based on the query. Otherwise, the query will search for all results that match the query parameters in the repository and then filter them based on the path.</li> 
   <li>If the query uses sorting, have an explicit property definition for the sorted property and set <span class="code">ordered</span> to <span class="code">true</span> for it. This will allow the results to be ordered as such in the index and save on costly sorting operations at query execution time.</li> 
   <li>Only put what is needed into the index. Adding unneeded features or properties will cause the index to grow and slow performance.</li> 
   <li>In a property index, having a unique property name would help to reduce the size on an index, but for Lucene indexes, use of <span class="code">nodeTypes</span> and <span class="code">mixins</span> should be made to achieve cohesive indexes. Querying a specific <span class="code">nodeType</span> or <span class="code">mixin</span> will be more performant than querying <span class="code">nt:base</span>. When using this approach, define <span class="code">indexRules</span> for the <span class="code">nodeTypes</span> in question.</li> 
   <li>If your queries are only being run under certain paths, then create those indexes under those paths. Indexes are not required to live at the root of the repository.</li> 
   <li>It is recommended to use a single index when all of the properties being indexed are related to allow Lucene to evaluate as many property restrictions as possible natively. Additionally, a query will only use one index, even when performing a join.</li> 
  </ul> 
  <h3>CopyOnRead</h3> 
  <p>In cases where the <span class="code">NodeStore</span> is stored remotely, an option called <span class="code">CopyOnRead</span> can be enabled. The option will cause the remote index to be written to the local filesystem when it is read. This can help to improve performance for queries that are often run against these remote indexes. </p> 
  <p>This can be configured in the OSGi console under the <strong>LuceneIndexProvider</strong> service and is enabled by default as of Oak 1.0.13.</p> 
  <h3>Removing Indexes</h3> 
  <p>When removing an index, it is always recommended to temporarily disable the index by setting the <span class="code">type</span> property to <span class="code">disabled</span> and do testing to ensure that your application functions correctly before actually deleting it. Note that an index is not updated while disabled, so it may not have the correct content if it is reenabled and may need to be reindexed.</p> 
  <p>After removing a property index on a TarMK instance, compaction will need to be run to reclaim any disk space that was in use. For Lucene indexes, the actual index content lives in the BlobStore, so a data store garbage collection would be required.</p> 
  <p>When removing an index on a MongoDB instance, the cost of deletion is proportional to the number of nodes in the index. Since deleting a large index can cause problems, the recommended approach is to disable the index and delete it only during a maintenance window, using a tool such as <strong>oak-mongo.js</strong>. Please note that this approach should not be employed for regular node content as it can introduce data inconsistencies.</p> 
  <note> 
   <p>For more information about oak-mongo.js, see the <a href="http://jackrabbit.apache.org/oak/docs/command_line.html">Command Line Tools section</a> of the Oak documentation.<br /> </p> 
  </note> 
  <h2>Re-indexing</h2>  
  <p>This section outlines the <strong>only</strong> acceptable reasons to re-index Oak indexes.</p> 
  <p>Outside the reasons outlined below, initiating re-indexes of Oak indexes will <strong>not</strong> change behavior or resolve issues, and unncessarily increase load on AEM.</p> 
  <p>Re-indexing of Oak indexes is to be avoided unless covered by a reasons in the tables below.</p> 
  <note> 
   <p>Prior to consulting the tables below to determine is re-indexing is useful,<strong> always </strong>verify:</p> 
   <ul> 
    <li>the query is correct </li> 
    <li>the query resolves to the expected index (using <a href="../../../sites/administering/using/operations-dashboard.md#diagnosistools" target="_blank">Explain Query</a>)</li> 
    <li>the indexing process has completed</li> 
   </ul> 
   <p> </p> 
  </note> 
  <h3>Oak index configuration changes</h3> 
  <p>The only acceptable non-erring conditions for re-indexing Oak indexes, is if the configuration of an Oak index has changed.</p> 
  <p><i>Re-indexing should always be approached with proper consideration on its impact to AEM's overall performance, and performed during periods of low activity or maintenance windows.</i><br /> </p> 
  <p>The following detail possible issues together with resolutions:</p> 
  <ul> 
   <li><a href="#propertyindexdefinitionchange">Property Index Definition Change</a></li> 
   <li><a href="#luceneindexdefinitionchange">Lucene Index Definition Change</a></li> 
  </ul> 
  <h4>Property Index Definition Change</h4> 
  <ul> 
   <li>Applies for/if: 
    <ul> 
     <li>All Oak versions</li> 
     <li>Only <a href="http://jackrabbit.apache.org/oak/docs/query/property-index.html">property indexes</a></li> 
    </ul> </li> 
   <li>Symptoms: 
    <ul> 
     <li>Nodes existing prior to property index's definition update missing from results</li> 
    </ul> </li> 
   <li>How to Verify: 
    <ul> 
     <li>Determine if missing nodes were created/modified prior to the deployment of the updated index definition.</li> 
     <li>Verify the <span class="code">jcr:created</span> or <span class="code">jcr:lastModified</span> properties of any missing nodes against the index's modified time</li> 
    </ul> </li> 
   <li>How to Resolve: 
    <ul> 
     <li><a href="/sites/deploying/using/best-practices-for-queries-and-indexing.html?cq_ck=1496173166571#HowtoReindex">Re-index</a> the lucene index<br /> </li> 
     <li>Alternatively, touch (perform a benign write operation) to the missing nodes 
      <ul> 
       <li>Requires manual touches or custom code</li> 
       <li>Requires the set of missing nodes to be known</li> 
       <li>Requires changing any property on the node</li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
  <h4>Lucene Index Definition Change</h4> 
  <ul> 
   <li>Applies for/if: 
    <ul> 
     <li>All Oak versions</li> 
     <li>Only <a href="http://jackrabbit.apache.org/oak/docs/query/lucene.html">lucene indexes</a></li> 
    </ul> </li> 
   <li>Symptoms: 
    <ul> 
     <li>Lucene index does not contain expected results</li> 
     <li>Query results do not reflect expected behavior of index definition</li> 
     <li>Query plan does not report expected output based on index definition</li> 
    </ul> </li> 
   <li>How to Verify: 
    <ul> 
     <li>Verify the index definition was changed using the Lucene Index statistics JMX Mbean (LuceneIndex), method <span class="code">diffStoredIndexDefinition</span>.</li> 
    </ul> </li> 
   <li>How to Resolve: 
    <ul> 
     <li>Oak versions prior to 1.6: 
      <ul> 
       <li><a href="#howtoreindex">Re-index</a> the lucene index</li> 
      </ul> </li> 
     <li>Oak versions 1.6+ 
      <ul> 
       <li>If existing content is not effected by the changes then only a refresh is needed 
        <ul> 
         <li><a href="http://jackrabbit.apache.org/oak/docs/query/lucene.html#stored-index-definition">Refresh</a> the lucene index by setting [oak:queryIndexDefinition]@refresh=true</li> 
        </ul> </li> 
       <li>Else, <a href="#howtoreindex">re-index</a> the lucene index 
        <ul> 
         <li>Note: The index state from the last good re-indexing (or initial indexing) will be used until a new re-indexing is triggered</li> 
        </ul> </li> 
      </ul> </li> 
    </ul> </li> 
  </ul> 
  <h3>Erring and exceptional situations</h3> 
  <p>The following table describes the only acceptable erring and exceptional situations where re-indexing Oak indexes will resolve the issue.</p> 
  <p>If an issue is experienced on AEM that does not match the criteria outlined below, do <strong>not</strong> re-index any indexes, as it will not resolve the issue.</p> 
  <p>The following detail possible issues together with resolutions:</p> 
  <ul> 
   <li><a href="#luceneindexbinaryismissing">Lucene Index Binary is Missing</a></li> 
   <li><a href="#luceneindexbinaryiscorrupt">Lucene Index Binary is Corrupt</a></li> 
  </ul> 
  <h4>Lucene Index Binary is Missing</h4> 
  <ul> 
   <li>Applies for/if: 
    <ul> 
     <li>All Oak versions</li> 
     <li>Only <a href="http://jackrabbit.apache.org/oak/docs/query/lucene.html">lucene indexes</a></li> 
    </ul> </li> 
   <li>Symptoms: 
    <ul> 
     <li>Lucene index does not contain expected results</li> 
    </ul> </li> 
   <li>How to Verify: 
    <ul> 
     <li>The error log file contains an exception saying a binary of the Lucene index is missing</li> 
    </ul> </li> 
   <li>How to Resolve: 
    <ul> 
     <li>Perform a traversing repository check; for example:<br /> <a href="http://localhost:4502/system/console/repositorycheck">http://localhost:4502/system/console/repositorycheck</a><br /> traversing the repository determines if other binaries (besides lucene files) are missing</li> 
     <li>If binaries other than lucene indexes are missing, restore from backup</li> 
     <li>Otherwise, <a href="#howtoreindex">re-index</a> <i>all</i> lucene indexes</li> 
     <li>Note:<br /> This condition is indicative of a misconfigured datastore that may result in ANY binary (eg. assets binaries) to go missing.<br /> In this case, restore to the last known good version of the repository to recover all missing binaries.</li> 
    </ul> </li> 
  </ul> 
  <h4>Lucene Index Binary is Corrupt</h4> 
  <ul> 
   <li>Applies for/if: 
    <ul> 
     <li>All Oak versions</li> 
     <li>Only <a href="http://jackrabbit.apache.org/oak/docs/query/lucene.html">lucene indexes</a></li> 
    </ul> </li> 
   <li>Symptoms: 
    <ul> 
     <li>Lucene index does not contain expected results</li> 
    </ul> </li> 
   <li>How to Verify: 
    <ul> 
     <li>The <span class="code">AsyncIndexUpdate</span> (every 5s) will fail with an exception in the error.log:<br /> <span class="code">...a Lucene index file is corrupt...</span></li> 
    </ul> </li> 
   <li>How to Resolve: 
    <ul> 
     <li>Remove the local copy of the lucene index 
      <ol> 
       <li>Stop AEM</li> 
       <li>Delete the local copy of the lucene index at <span class="code">crx-quickstart/repository/index</span></li> 
       <li>Restart AEM</li> 
      </ol> </li> 
     <li>If this does not resolve the issue, and the <span class="code">AsyncIndexUpdate</span> exceptions persist then: 
      <ol> 
       <li><a href="#howtoreindex">Re-index</a> the erring index</li> 
       <li>Also file an <a href="https://helpx.adobe.com/support.html">Adobe Support</a> ticket</li> 
      </ol> </li> 
    </ul> </li> 
  </ul> 
  <h3>How to Re-index</h3> 
  <note> 
   <p>In AEM 6.4, <a href="../../../sites/deploying/using/indexing-via-the-oak-run-jar.md#reindexingapproachdecisiontree" target="_blank">oak-run.jar is the ONLY supported method</a> for re-indexing on MongoMK or RDBMK repositories.</p> 
  </note> 
  <h4>Re-indexing Property indexes</h4> 
  <ul> 
   <li>Use <a href="../../../sites/deploying/using/oak-run-indexing-usecases.md#usecase3reindexing" target="_blank">oak-run.jar</a> to re-index the property index</li> 
   <li>Set the async-reindex property to true on the property index<br /> 
    <ul> 
     <li><span class="code">[oak:queryIndexDefinition]@reindex-async=true</span></li> 
    </ul> </li> 
   <li>Re-index the property index asynchronously using the Web Console via the <strong>PropertyIndexAsyncReindex</strong>MBean;<br /> for example,<br /> <a href="http://localhost:4502/system/console/jmx/org.apache.jackrabbit.oak%3Aname%3Dasync%2Ctype%3DPropertyIndexAsyncReindex">http://localhost:4502/system/console/jmx/org.apache.jackrabbit.oak%3Aname%3Dasync%2Ctype%3DPropertyIndexAsyncReindex</a></li> 
  </ul> 
  <h4>Re-indexing Lucene Property indexes</h4> 
  <ul> 
   <li>Use <a href="../../../sites/deploying/using/oak-run-indexing-usecases.md#usecase3reindexing" target="_blank">oak-run.jar to re-index</a> the Lucene Property index.</li> 
   <li>Set the async-reindex property to true on the 
    <g class="gr_ gr_7 gr-alert gr_spell gr_inline_cards gr_disable_anim_appear ContextualSpelling ins-del multiReplace" data-gr-id="7" id="7">
      lucene 
    </g> property index 
    <ul> 
     <li><span class="code">[oak:queryIndexDefinition]@reindex-async=true</span></li> 
    </ul> </li> 
  </ul> 
  <note> 
   <p>The preceding section summarizes and frames the Oak re-indexing guidance from the <a href="http://jackrabbit.apache.org/oak/docs/query/indexing.html#reindexing" target="_blank">Apache Oak documentation</a> in the context of AEM.</p> 
  </note> 
  <h3>Text Pre-extraction of Binaries</h3> 
  <p>Text pre-extraction is the process of extracting and processing text from binaries, directly from the Data Store via an isolated process, and directly exposing the extracted text to subsequent re/indexings of Oak indexes.</p> 
  <ul> 
   <li>Oak text pre-extraction is recommended for re/indexing Lucene indexes on repositories with large volumes of files (binaries) that contain extractable text (eg. PDFs, Word Docs, PPTs, TXT, etc.) that qualify for full-text search via deployed Oak indexes; for example <span class="code">/oak:index/damAssetLucene</span>.</li> 
   <li>Text pre-extraction will only benefit the re/indexing of Lucene indexes, and NOT Oak property indexes, since property indexes do not extract text from binaries.</li> 
   <li>Text pre-extraction has a high positive impact when the full-text re-indexing of text-heavy binaries (PDF, Doc, TXT, etc.), where as a repository of images will not enjoy the same efficiencies since images do not contain extractable text.</li> 
   <li>Text pre-extraction performs the extraction of full-text search related text in a extra-efficient manner, and exposes it to the Oak re/indexing process in a way that is extra-efficient to consume. </li> 
  </ul> 
  <h4>When CAN text pre-extraction be used?</h4> 
  <p>Re-indexing an <strong>existing</strong> lucene index with binary extraction enabled</p> 
  <ul> 
   <li>Re-indexing processing <strong>all</strong> candidate content in the repository; when the binaries to extract full-text from are numerous or complex, an increased computational burden to perform the the full-text extraction is placed on AEM. Text pre-extraction moves the "computationally costly work" of text-extraction into an isolated process that directly accesses AEM's Data Store, avoiding overhead and resource contention in AEM.</li> 
  </ul> 
  <p>Supporting the deployment of a <strong>new</strong> lucene index to AEM with binary extraction enabled</p> 
  <ul> 
   <li>When a new index (with binary extraction enabled) is deployed into AEM, Oak automatically indexes all candidate content on the next async full-text index run. For the same reasons described in re-indexing above, this may result in undue load on AEM.</li> 
  </ul> 
  <h4>When can text pre-extraction NOT be used?</h4> 
  <p>Text pre-extraction cannot be used for new content added to the repository, nor is it necessary.</p> 
  <p>New content is added to the repository will naturally and incrementally be indexed by the async full-text indexing process (by default, every 5 seconds).</p> 
  <p>Under normal operation of AEM, for example uploading Assets via the Web UI or programmatic ingest of Assets, AEM will automatically and incrementally full-text index the new binary content. Since the amount of data is incremental and relatively small (approximately the amount of data that can be persisted to the repository in 5 seconds), AEM can perform the full-text extraction from the binaries during indexing without effecting overall system performance.</p> 
  <h4>Prerequisites to using text pre-extraction</h4> 
  <ul> 
   <li>You will be re-indexing a lucene index that performs full-text binary extraction or deploying a new index that will full-text index binaries of existing content</li> 
   <li>The content (binaries) from which to pre-extract text, must be in the repository</li> 
   <li>A maintenance window to generate the CSV file AND to perform the final re-indexing</li> 
   <li>Oak version: 1.0.18+, 1.2.3+</li> 
   <li><a href="http://mvnrepository.com/artifact/org.apache.jackrabbit/oak-run/" target="_blank">oak-run.jar </a>version 1.7.4+</li> 
   <li>A file system folder/share to store extracted text accessible from the indexing AEM instance(s) 
    <ul> 
     <li>The Text pre-extraction OSGi config requires a file system path to the extracted text files, so they must be accessible directly from the AEM instance (local drive or file share mount)</li> 
    </ul> </li> 
  </ul> 
  <h4>How to perform text pre-extraction</h4> 
  <note> 
   <p><i><strong>The oak-run.jar commands outlined below are fully enumerated at <a href="https://jackrabbit.apache.org/oak/docs/query/pre-extract-text.html">https://jackrabbit.apache.org/oak/docs/query/pre-extract-text.html</a></strong></i></p> 
   <p>The above diagram and steps below serve to explain and compliment the technical text pre-extraction steps outlined in the Apache Oak documentation.</p> 
   <p><i> </i></p> 
  </note> 
  <img alt="Text pre-extraction process flow" imageRotate="0" src="assets/chlimage_1-142.png" title="Text pre-extraction process flow" /> 
  <p><strong>Generate 
    <g class="gr_ gr_43 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar only-ins doubleReplace replaceWithoutSep" data-gr-id="43" id="43">
      list 
    </g> of content to pre-extract</strong></p> 
  <p><em>Execute Step 1(a-b) during a maintenance window/low-use period as the Node Store is traversed during this operation, which may incur significant load on the system.</em></p> 
  <p style="margin-left: 40px;">1a. Execute <span class="code">oak-run.jar --generate</span> to create a list of nodes that will have their text pre-extracted.</p> 
  <p style="margin-left: 40px;">1b. List of nodes (1a) is stored to the file system as a CSV file</p> 
  <p>Note the entire Node Store is traversed (as specified by the paths in the oak-run command) every time <span class="code">--generate</span> is executed, and a <strong>new</strong> CSV file is created. The CSV file is <strong>not</strong> re-used between discrete executions of the text pre-extraction process (Steps 1 - 2)</p> 
  <p><strong>Pre-extract text to file system</strong></p> 
  <p><em>Step 2(a-c) can be executed during normal operation of AEM is it only interacts w the Data Store.</em></p> 
  <p style="margin-left: 40px;">2a. Execute <span class="code">oak-run.jar --tika</span> to pre-extract text for the binary nodes enumerated in the CSV file generated in (1b)</p> 
  <p style="margin-left: 40px;">2b. The process initiated in (2a) accesses binary nodes defined in the CSV in Data Store 
   <g class="gr_ gr_62 gr-alert gr_gramm gr_inline_cards gr_run_anim Punctuation only-del replaceWithoutSep" data-gr-id="62" id="62">
     directly, 
   </g> and extracts text.</p> 
  <p style="margin-left: 40px;">2c. 
   <g class="gr_ gr_54 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar only-ins replaceWithoutSep" data-gr-id="54" id="54">
     Extracted 
   </g> text is stored on file system in a format ingestible by the Oak re-indexing process (3a)</p> 
  <p> 
   <g class="gr_ gr_57 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar only-ins replaceWithoutSep" data-gr-id="57" id="57">
     Pre-extracted 
   </g> text is identified in the CSV by the binary fingerprint. If the binary file is the same, the same pre-extracted text can be used across AEM instances. Since AEM Publish is usually a sub-set of AEM Author, the pre-extracted text from AEM Author can often be used to re-index AEM Publish as well (assuming the AEM Publish have file-system access to the extracted text files).</p> 
  <p>Pre-extracted text can be incrementally added to over time. Text pre-extraction will skip extraction for previously extracted binaries, so it is best practice to keep pre-extracted text in case re-indexing must happen again in the future (assuming the extracted contents is not prohibitively large. If it is, 
   <g class="gr_ gr_36 gr-alert gr_gramm gr_inline_cards gr_run_anim Grammar multiReplace" data-gr-id="36" id="36">
     evaluate 
   </g> zipping the contents in the 
   <g class="gr_ gr_37 gr-alert gr_gramm gr_inline_cards gr_run_anim Punctuation only-del replaceWithoutSep" data-gr-id="37" id="37">
     interim, 
   </g> since text compresses well).</p> 
  <p> </p> 
  <p><strong>Re-index Oak indexes, sourcing full-text from Extracted Text files</strong></p> 
  <p><em>Execute re-indexing (Steps 3a-b) during a maintenance/low-use period as the Node Store is traversed during this operation, which may incur significant load on the system.</em></p> 
  <p style="margin-left: 40px;">3a. <a href="#howtoreindex">Re-index</a> of Lucene indexes is invoked in AEM</p> 
  <p style="margin-left: 40px;">3b. The Apache Jackrabbit Oak DataStore PreExtractedTextProvider OSGi config (configured to point at the Extracted text via a file system path) instructs Oak to sourced full-text text from the Extracted 
   <g class="gr_ gr_41 gr-alert gr_gramm gr_inline_cards gr_run_anim Punctuation only-del replaceWithoutSep" data-gr-id="41" id="41">
     Files, 
   </g> and avoids directly hitting and processing the data stored in the repository.</p> 
  <p> </p> 
 </body> 
</html>